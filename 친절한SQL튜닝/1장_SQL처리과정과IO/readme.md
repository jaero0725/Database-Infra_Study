# SQL 처리과정과 I/O
## 1.1 SQL 파싱과 최적화

* 옵티마이저가 SQL을 어떻게 처리하는지? <br>
사용자 -(SQL)-> 옵티마이저 -(실행계획)-> 프로시저 <br>
- 옵티마이저가 프로그래밍을 대신해줌
- DBMS 내부에서 프로시저를 작성하고 컴파일 해서 실행 가능한 상태로 만드는 전 과정을 'SQL 최적화'라고 함. 

### 1.1.2 SQL 최적화 (SQL을 실행하기 전 최적화 과정은?)
1) SQL 파싱 (SQL Parser가 진행)
- 사용자에게 SQL을 전달받으면 가장 먼저 SQL Parser가 파싱을 진행한다. 
- 파싱트리 생성 : SQL 문을 이루는 개별 구서용소를 분석해서 파싱 트리 생성
- Syntax 체크 : 문법적 오류가 없는지 확인. 사용할 수 없는 키워드 사용했는지, 순서가 올바르지 않은지 확인
- Semantic 체크 : 의미상 오류가 없는지 확인. 존재하지 않는 테이블 또는 컬럼 사용했는지, 권한 체크

2) SQL 최적화 (Optimizer가 진행)
- 옵티마이저가 미리 수집한 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성해서 비교한 후 가장 효율적인 하나를 선택.
- DB 성능을 결정하는 가장 핵심적인 엔진

3) 로우 소스 생성 (로우 소스 생성기 Row-Souce Generatorr가 진행)
- SQL옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅 하는 단계. 

### 1.1.3 SQL옵티마이저 
-최적의 데이터 엑세스 경로를 선택해 주는 DBMS의 핵심 엔진 
![image](https://user-images.githubusercontent.com/55049159/232272299-6a4fb047-bf67-4938-9ddc-40a6d3418734.png)
1) 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아낸다.
2) 데이터 딕셔너리(Data Dictionary)에 미리 수집해 둔 오브젝트 통계 및 시스템 통계 정보를 이용해 각 실행계획의 예상비용을 산정한다.
3) 최저 비용을 나타내는 실행계획을 선택한다. 

### 1.1.5 옵티마이저 힌트 
* 주의사항
* 콤마사용 X
* 스키마명 X
* Alias 썼으면 그대로 쓰기 
<hr>

## 1.2 SQL 공유 및 재사용
* SQL 문제  : SQL 에서 소프트 파싱과 하드 파싱의 차이점에 대해서 설명해주실 수 있나요?

```
먼저 SQL 실행은 파싱(파서에의해) -> 최적화(옵티마이저에의해) -> 로우 소스(로우소스 생성기) 생성과정으로 진행되는데
이런 과정을 거치면, SGA영역에 있는 '라이브러리 캐시'에 저장되어 반복 재사용할 수 있게 됩니다. 
파싱을 하고 라이브러리캐시에서 존재하는지 확인하고 저장되어있자면 바로 실행 되는 것이 "소프트 파싱" 이라고 합니다.
반면 라이브러리 캐시에 존재하지 않는다면 최적화, 로우소스 생성 과정을 거쳐 실행되는 데 이것을 "하드 파싱" 이라고 합니다. 
```

SQL파싱, 최적화, 로우 소스 생성과정 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 해두는 메모리 공간을 SGA에 있는 라이브러리 캐시라고 합니다. <br>

```

사용자가 SQL문을 전달하면 DBMS는 SQL을 파싱한후 SQL이 라이브러리 캐시에 존재하는지 확인한다.
캐시에서 찾으면 곧바로 실행 단계로 넘어가지만, 찾지 못하면 최적화 단계를 거칩니다. 
SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것을 '소프트 파싱'이라고 하고, 
찾는데 실패해 최적화 및 로우 소스 생성 단계까지 모두 거치는 것을 '하드파싱 이라고 합니다. 

```
![image](https://user-images.githubusercontent.com/55049159/232272982-d866f0af-f0d6-470a-b881-6bc2ad1ad9bd.png)

#### SQL 최적화 과정은 왜 하드한가?
- 5개 테이블을 조인한다고 생각하면, 조인 순서만해도 120가지고, NL조인, 소트 머지조인, 해시 조인등 다양한 조인 방식, 인덱스를 어떻게 쓸지 등등 다양한 방식이 제공되는데 대충 계산해도 수십만 가지 경우의 수가 존재한다. 순식간에 SQL옵티마이저가 많은 연산을 한다. 
- 테이브, 컬럼 인덱스 구조에 관한 기본정보
- 오브젝트 통계
- 시스템 통계
- 옵티마이저 관련 파라미터
=> DB에서 이루어지는 처리과정은 대부분 I/O 작업에 집중되지만 하드 파싱은 CPU를 많이 소비하는 몇 안되는 작업중 하나이다. 
=> 이렇게 Hard 한 작업을 거쳐 생성한 내부 프로시저를 한 번만 사용하고 버리면 정말 비효율적이므로 라이브러리 캐시가 필요한 이유가 여기 있다. 

## DB버퍼 캐시란?

```
라이브러리 캐시가 SQL과 실행계획, DB 저장형 함수/프로시저 등을 캐싱하는 '코드 캐시'라고 한다면 
버퍼 캐시는 '데이터 캐시' 라고 할 수 있다. 
디스크에서 어렵게 읽은 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 반복적인 I/O Call을 줄이는데 있다. 

버퍼 캐시는 공유메모리 영역에 있으므로 같은 블록을 읽는 다른 프로세스도 득을 본다. 

V$SGA 뷰를 통해 확인할 수 있음. 
```
![image](https://user-images.githubusercontent.com/55049159/232276434-3ffec2e6-959b-4486-8ded-17621c5ffa07.png)

## Single Block I/O vs Multi Block I/O

```
한 번에 한 블록씩 요청해서 메모리에 적재하는 방식을 Single Block I/O라고 한다.
많은 벽돌을 실어 나를 때 손수레를 이용하는 것 처럼 한 번에 여러 블록 씩 요청해서 메모리에 적재하는 방식을 Multiblock I/O 라고 한다. 

인덱스를 이용할 떄는 기본적으로 인덱스와 테이블 블록 모두 Single Block I/O 방식을 사용한다. 
인덱스는 소량 데이터를 읽을 때 주로 사용하므로 이 방식이 효율적이다. 

반대로 많은 데이터 블록을 읽을 때는 Multiblock I/O 방식이 효율적이다. 
그래서 인덱스를 이용하지 않고 테이블 전체를 스캔할때 이 방식을 이용한다. 
테이블이 클수록 Multiblock I/O 단위도 크면 좋다. (프로세스가 잠잔느 횟수를 줄여주므로)

DBMS 블록 사이즈가 얼마건 간에 OS 단에서는 보통 1MB 단위로 I/O를 수행한다.
한 번 I/O할때 1MB크기의 손수레를 이용하는 셈이다. 
테이블 전체 블록을 읽을 떄는 손수레에 한 번에 담을 수 있는 만큼 최대한 많이 담아야 유리하다. 


오라클에서 손수레에 한 번에 담는 양은 db_file_bultiblock_read_count 파라미터로 정한다.

```

![image](https://user-images.githubusercontent.com/55049159/232277165-47ef3a30-a333-42fe-8d4a-a8ac3a301846.png)
