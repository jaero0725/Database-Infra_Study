# SQL 처리과정과 I/O
##  옵티마이저가 SQL을 어떻게 처리하는지? 

```
사용자 -(SQL)-> 옵티마이저 -(실행계획)-> 프로시저 <br>
- 옵티마이저가 프로그래밍을 대신해줌
- DBMS 내부에서 프로시저를 작성하고 컴파일 해서 실행 가능한 상태로 만드는 전 과정을 'SQL 최적화'라고 함. 
```

### SQL을 실행하기 전 최적화 과정은 어떻게 되는가?

```
1) SQL 파싱 (SQL Parser가 진행)
- 사용자에게 SQL을 전달받으면 가장 먼저 SQL Parser가 파싱을 진행한다. 
- 파싱트리 생성 : SQL 문을 이루는 개별 구서용소를 분석해서 파싱 트리 생성
- Syntax 체크 : 문법적 오류가 없는지 확인. 사용할 수 없는 키워드 사용했는지, 순서가 올바르지 않은지 확인
- Semantic 체크 : 의미상 오류가 없는지 확인. 존재하지 않는 테이블 또는 컬럼 사용했는지, 권한 체크

2) SQL 최적화 (Optimizer가 진행)
- 옵티마이저가 미리 수집한 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성해서 비교한 후 가장 효율적인 하나를 선택.
- DB 성능을 결정하는 가장 핵심적인 엔진

3) 로우 소스 생성 (로우 소스 생성기 Row-Souce Generatorr가 진행)
- SQL옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅 하는 단계. 
```

### SQL옵티마이저란?
```
-최적의 데이터 엑세스 경로를 선택해 주는 DBMS의 핵심 엔진 

1) 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아낸다.
2) 데이터 딕셔너리(Data Dictionary)에 미리 수집해 둔 오브젝트 통계 및 시스템 통계 정보를 이용해 각 실행계획의 예상비용을 산정한다.
3) 최저 비용을 나타내는 실행계획을 선택한다. 

 옵티마이저 힌트 사용할때 주의
* 주의사항
* 콤마사용 X
* 스키마명 X
* Alias 썼으면 그대로 쓰기 

```

![image](https://user-images.githubusercontent.com/55049159/232272299-6a4fb047-bf67-4938-9ddc-40a6d3418734.png)

<hr>

##  SQL 에서 소프트 파싱과 하드 파싱의 차이점에 대해서 설명해주실 수 있나요?
```
먼저 SQL 실행은 파싱(파서에의해) -> 최적화(옵티마이저에의해) -> 로우 소스(로우소스 생성기) 생성과정으로 진행되는데
이런 과정을 거치면, SGA영역에 있는 '라이브러리 캐시'에 저장되어 반복 재사용할 수 있게 됩니다. 
파싱을 하고 라이브러리캐시에서 존재하는지 확인하고 저장되어있자면 바로 실행 되는 것이 "소프트 파싱" 이라고 합니다.
반면 라이브러리 캐시에 존재하지 않는다면 최적화, 로우소스 생성 과정을 거쳐 실행되는 데 이것을 "하드 파싱" 이라고 합니다. 
```

SQL파싱, 최적화, 로우 소스 생성과정 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 해두는 메모리 공간을 SGA에 있는 라이브러리 캐시라고 합니다. <br>

```

사용자가 SQL문을 전달하면 DBMS는 SQL을 파싱한후 SQL이 라이브러리 캐시에 존재하는지 확인한다.
캐시에서 찾으면 곧바로 실행 단계로 넘어가지만, 찾지 못하면 최적화 단계를 거칩니다. 
SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것을 '소프트 파싱'이라고 하고, 
찾는데 실패해 최적화 및 로우 소스 생성 단계까지 모두 거치는 것을 '하드파싱 이라고 합니다. 

```
![image](https://user-images.githubusercontent.com/55049159/232272982-d866f0af-f0d6-470a-b881-6bc2ad1ad9bd.png)

#### SQL 최적화 과정은 왜 하드한가?
- 5개 테이블을 조인한다고 생각하면, 조인 순서만해도 120가지고, NL조인, 소트 머지조인, 해시 조인등 다양한 조인 방식, 인덱스를 어떻게 쓸지 등등 다양한 방식이 제공되는데 대충 계산해도 수십만 가지 경우의 수가 존재한다. 순식간에 SQL옵티마이저가 많은 연산을 한다. 
- 테이브, 컬럼 인덱스 구조에 관한 기본정보
- 오브젝트 통계
- 시스템 통계
- 옵티마이저 관련 파라미터
=> DB에서 이루어지는 처리과정은 대부분 I/O 작업에 집중되지만 하드 파싱은 CPU를 많이 소비하는 몇 안되는 작업중 하나이다. 
=> 이렇게 Hard 한 작업을 거쳐 생성한 내부 프로시저를 한 번만 사용하고 버리면 정말 비효율적이므로 라이브러리 캐시가 필요한 이유가 여기 있다. 

## DB버퍼 캐시란?

```
라이브러리 캐시가 SQL과 실행계획, DB 저장형 함수/프로시저 등을 캐싱하는 '코드 캐시'라고 한다면 
버퍼 캐시는 '데이터 캐시' 라고 할 수 있다. 
디스크에서 어렵게 읽은 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 반복적인 I/O Call을 줄이는데 있다. 

버퍼 캐시는 공유메모리 영역에 있으므로 같은 블록을 읽는 다른 프로세스도 득을 본다. 

V$SGA 뷰를 통해 확인할 수 있음. 
```
![image](https://user-images.githubusercontent.com/55049159/232276434-3ffec2e6-959b-4486-8ded-17621c5ffa07.png)

## Single Block I/O vs Multi Block I/O 차이점에 대해서 설명?

```
한 번에 한 블록씩 요청해서 메모리에 적재하는 방식을 Single Block I/O라고 한다.
많은 벽돌을 실어 나를 때 손수레를 이용하는 것 처럼 한 번에 여러 블록 씩 요청해서 메모리에 적재하는 방식을 Multiblock I/O 라고 한다. 

인덱스를 이용할 떄는 기본적으로 인덱스와 테이블 블록 모두 Single Block I/O 방식을 사용한다. 
인덱스는 소량 데이터를 읽을 때 주로 사용하므로 이 방식이 효율적이다. 

반대로 많은 데이터 블록을 읽을 때는 Multiblock I/O 방식이 효율적이다. 
그래서 인덱스를 이용하지 않고 테이블 전체를 스캔할때 이 방식을 이용한다. 
테이블이 클수록 Multiblock I/O 단위도 크면 좋다. (프로세스가 잠잔느 횟수를 줄여주므로)

DBMS 블록 사이즈가 얼마건 간에 OS 단에서는 보통 1MB 단위로 I/O를 수행한다.
한 번 I/O할때 1MB크기의 손수레를 이용하는 셈이다. 
테이블 전체 블록을 읽을 떄는 손수레에 한 번에 담을 수 있는 만큼 최대한 많이 담아야 유리하다. 


오라클에서 손수레에 한 번에 담는 양은 db_file_bultiblock_read_count 파라미터로 정한다.

```

![image](https://user-images.githubusercontent.com/55049159/232277165-47ef3a30-a333-42fe-8d4a-a8ac3a301846.png)


##  Multi Block I/O 중간에 왜 Single Block I/O가 나타나는가?
![image](https://user-images.githubusercontent.com/55049159/232277591-c148ac9d-3087-4f04-a52f-6a7fad19b549.png)

## Table Full Scan vs Index Range Scan 의 차이? 

```
* Table Full Scan이 무조건 안좋은가? 

실행계획에 빨간색이 많이 보여서 튜닝을 하는 것은 아니다?
Table Full Scan 찾아내기식 실행계획 분석은 실제로 SQL 성능을 향상하는데 큰 도움이 되지 않는다.
인덱스를 사용해야 하는 상황인데 Table Full Scan 하는 경우도 있으므로 전혀 의미없다고 할 수는 없지만 
Table Full Scan은 피해야 한다는 많은 개발자의 인식과 달리 인덱스가 SQL 성능을 떨어뜨리는 경우도 상당히 많기 떄문이다.

한번에 많은 데이터를 처리하는 집계용 SQl과 배치 프로그램이 특히 그렇다. 그래서 이들 프로그램에서 사용하는 SQL은 온라인 SQL보다 튜닝하기 비교적 쉽다. 
상당수가 Table Full Scan을 유도하면 성능이 빨라ㅣ진다. 
조인을 포함한 SQL이면 조인 메소드로 "해시 조인"을 선택 해주면 된다.

* 인덱스를 이용하는데 왜 성능이 더 느릴까?
I/O 메커니즘 관점에서 Table Full Scan과 index Range Scan의 본질을 해석해보면 인덱스를 이용해 많은 데이터를 읽을 때 왜 성능이 느린지 쉽게 이해 할 수 있다.


* Full Scan이 인덱스보다 효율적인 경우는 일반적으로 다음과 같은 경우입니다.

테이블의 크기가 작은 경우: 테이블의 크기가 작은 경우, Full Scan이 인덱스를 사용하는 것보다 더 빠를 수 있습니다. 인덱스를 사용하는 것은 추가적인 I/O 비용이 발생하기 때문입니다.

특정 컬럼을 검색하는 쿼리: 인덱스는 특정 컬럼에 대해 검색할 때 유용합니다. 그러나 전체 레코드를 스캔해야 하는 쿼리라면 Full Scan이 더 빠를 수 있습니다.

테이블에 대한 통계 정보가 없는 경우: 테이블에 대한 통계 정보가 없는 경우, 옵티마이저는 인덱스를 사용하는 것보다 Full Scan을 선택할 가능성이 높습니다. 이는 인덱스를 사용하는 것이 더 많은 I/O 비용을 발생시킬 수 있기 때문입니다.

테이블의 모든 데이터를 반환하는 쿼리: 테이블의 모든 레코드를 반환하는 쿼리라면 Full Scan이 더 빠를 수 있습니다. 인덱스를 사용하는 것은 불필요한 추가적인 I/O 비용을 발생시키기 때문입니다.

*
1. Table Full Scan
Table Full Scan은 시퀀셜 엑세스와 Multiblock I/O 방식으로 디스크 블록을 읽는다. 
한블록에 속한 모든 레코드를 한 번에 읽어 들이고, 캐시에서 못찾으면 'I/O call'을 통해 인접한 수십~수백 개 블록을 한꺼번에 I/O하는 메커니즘이다. 
이 방식을 사용하는 SQL은 스토리지 스캔 성능이 좋아지는 만큼 성능도 좋아진다. 
시퀀셜 엑세스와 Multiblock I/O가 아무리 좋아도 수십~수백 건의 소량 데이터를 찾을 때 수백만~수천만건 데이터를 스캔하는 건 비효율적이다. 
큰테이블에서 소량 데이터를 검색할때는 반드시 인덱스를 이용해야 한다. 

2. Index Range Scan
Index Range Scan을 통한 테이블 엑세스는 랜덤 엑세스와 Single Block I/O 방식으로 디스크 블록을 읽는다. 
캐시에서 블록을 못 찾으면, 레코드를 하나 읽기 위해 매번 I/O call을 하는 메커니즘이다. 
따라서 많은 데이터를 읽을 떄는 Table Full Scan보다 불리하다. 
이 방식을 사용하는 SQL은 스토리지 스캔 성능이 수십 배 좋아져도 성능이 조금 밖에 좋아지지 않는다. 

=> 인덱스에 대한 맹신은 금물이다. 인덱스가 항상 옳은 것은 아니며, Table Full scan이 항상 나쁜 것도 아니다. 
인덱스는 큰 테이블에서 아주 적은 일부 데이터를 빨리 찾기 위한 도구 일분 모든 성능 문제를 인덱스로 해결하려 해선 안된다.
읽을 데이터가 일정량을 넘으면 인덱스 보다 Table Full Scan이 유리하다.


```

## 캐시 탐색 메커니즘?
```

Driect Path I/O를 제외한 모든 블록 I/O는 메모리 버퍼 캐시를 경유한다. 

오라클의 캐시 메커니즘은 데이터베이스의 성능을 향상시키기 위해 사용됩니다. 캐시는 자주 사용되는 데이터를 미리 메모리에 저장하여 디스크에 접근하지 않고 바로 사용할 수 있도록 합니다.

오라클은 두 가지 캐시 메커니즘을 사용합니다. 하나는 데이터베이스 버퍼 캐시이고, 다른 하나는 공유 풀 캐시입니다.

데이터베이스 버퍼 캐시는 디스크에서 읽은 데이터를 메모리에 보관합니다. 이렇게 하면 동일한 데이터를 빠르게 접근할 수 있습니다. 오라클은 LRU(Least Recently Used) 알고리즘을 사용하여 버퍼 캐시에서 가장 오래된 데이터를 제거합니다. 이렇게 함으로써 최근에 사용된 데이터를 캐시에 보관하고, 자주 사용되지 않는 데이터를 제거함으로써 버퍼 캐시의 성능을 향상시킵니다.

공유 풀 캐시는 데이터베이스에서 공통적으로 사용되는 오브젝트를 캐시합니다. 이 캐시는 공유 메모리 영역에 저장되며, 데이터베이스 인스턴스를 공유하는 모든 프로세스에서 사용할 수 있습니다. 이렇게 하면 오브젝트를 반복적으로 읽어오는 작업을 줄일 수 있습니다. 공유 풀 캐시는 LRU 알고리즘을 사용하여 오래된 오브젝트를 제거합니다.

이러한 캐시 메커니즘을 통해 오라클은 빠른 응답 시간과 높은 처리량을 제공할 수 있습니다.
```
