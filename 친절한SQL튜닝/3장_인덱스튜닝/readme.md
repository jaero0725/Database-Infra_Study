# 인덱스 튜닝
## 테이블 엑세스 최소화
<hr>

## 인덱스를 사용해도 되는데 굳이 왜 파티션 Pruning은 왜 필요한가? 
## 인덱스를 사용하는데도 왜 쿼리가 느릴까?

```
SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니면, 인덱스를 스캔한 후 반드시 테이블을 엑세스 한다.

* ROWID는 포인터가 아니다. 논리적주소이다.
인덱스를 스캔하는 이유는,검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 거기서 테이블 레코드를 찾아가기 위한 주소값(ROWID)를 얻으려는데 있다.
인덱스 ROWID는 포인터가 아니다. ROWID는 논리적 주소이다. 
디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담는다. 


=> 디스크 DB가 사용하는 ROWID에 의한 테이블 엑세스가 고비용 연산이기 떄문이다. 
=> 클러시터링 팩터(군집성 계수)가 좋을 수록 인덱스 검색 효율이 좋다. 
(CF가 좋은 컬럼에 생성한 인덱스가 검색 효율이 좋다. 
테이블 엑세스량에 비해 블록 I/O가 적게 발생한다. )
```

## 메인메모리DB(MMDB)가 잘 튜닝된 OLTP성 DB시스템 보다 느린이유?

```

메인메모리 DB의 경우 인스턴스를 기동하면 디스크에 저장된 데이터를 버퍼캐시로 로딩하고 이어서 인덱스를 생성한다. 
이때 인덱스는 오라클처럼 디스크 상의 주소정보를 갖는게 아니라 메모리상의 주소정보, 즉 포인터를 갖는다. 
따라서 인덱스를 경유해 테이블을 엑세스하는 비용이 오라클과 비교할 수 없을 정도로 낮다. 

-> 일반 DBMS에서 인덱스 ROWID를 이용한 테이블 엑세스가 생각만큼 빠르지 않은 이유이다. 

```

## 인덱스 레코드마다 테이블 레코드를 건건이 블록 단위 I/O 한다면, CF가 달라도 블록 I/O 발생량에 차이가 없어야 하지 않나?

```
인덱스 ROWID로 테이블을 엑세스할 때, 오라클은 래치 획득과 해시 체인 스캔 과정을 거쳐 어렵게 찾아간 테이블 블록에 대한 포인터를 바로 해제하지 않고 일단 유지한다.
이를 버퍼 Pinning이라고 부른다
이 상태에서 다음 인덱스 레코드를 읽었는데, 마침 직전과 같은 테이블 블록을 가리킨다. 
그러면 래치 획득과 해시 체인 스캔 과정을 생략하고 바로 테이블 블록을 읽을 수 있다.
논리적인 블록 I/O과정을 생략할 수 있기 때문이다.


```

### 인덱스 손익 분기점이란?
- 인덱스 ROWID를 이요한 테이블 엑세스는 고비용 구조이므로 읽어야할 데이터가 일정량을 넘는 순가, 테이블 전체를 스캔하는 것 보다 오히려 느려진다.
- Index Range Scan에 의한 테이블 엑세스가 Table Full Scan보다 느려지는 지점을 '인덱스 손익 분기점' 이라고 한다. 

### 인덱스를 이용한 테이블 엑세스가 Table Full Scan보다 더 느려지게 만드는 핵심적이 요인
1) Table Full Scan은 시퀀셜 엑세스인 반면, 인덱스 ROWID를 이용한 테이블 엑세스는 랜덤 엑세스 방식이다.
2) Table Full Scan은 Mutliblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 엑세스는 Single Block I/O 방식이다.

=> 이런 요인에 의해 인덱스 손익분기점은 보통 5~20%의 낮은 수준에서 결정된다. 
=> 테이블 스캔이 항상 나쁜 것이 아니며, 인덱스 스캔이 항상 좋은 것도 아니다. 
=> 배치프로그램과 온라인 프로그램의 튜닝의 특징이 다르다는 걸 시사한다.





