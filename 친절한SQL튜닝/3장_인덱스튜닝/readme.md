# 인덱스 튜닝
## 테이블 엑세스 최소화
<hr>

## 인덱스를 사용해도 되는데 굳이 왜 파티션 Pruning은 왜 필요한가? 
## 인덱스를 사용하는데도 왜 쿼리가 느릴까?

```
SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니면, 인덱스를 스캔한 후 반드시 테이블을 엑세스 한다.

* ROWID는 포인터가 아니다. 논리적주소이다.
인덱스를 스캔하는 이유는,검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 거기서 테이블 레코드를 찾아가기 위한 주소값(ROWID)를 얻으려는데 있다.
인덱스 ROWID는 포인터가 아니다. ROWID는 논리적 주소이다. 
디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담는다. 


=> 디스크 DB가 사용하는 ROWID에 의한 테이블 엑세스가 고비용 연산이기 떄문이다. 
=> 클러시터링 팩터(군집성 계수)가 좋을 수록 인덱스 검색 효율이 좋다. 
(CF가 좋은 컬럼에 생성한 인덱스가 검색 효율이 좋다. 
테이블 엑세스량에 비해 블록 I/O가 적게 발생한다. )
```

## 메인메모리DB(MMDB)가 잘 튜닝된 OLTP성 DB시스템 보다 느린이유?

```

메인메모리 DB의 경우 인스턴스를 기동하면 디스크에 저장된 데이터를 버퍼캐시로 로딩하고 이어서 인덱스를 생성한다. 
이때 인덱스는 오라클처럼 디스크 상의 주소정보를 갖는게 아니라 메모리상의 주소정보, 즉 포인터를 갖는다. 
따라서 인덱스를 경유해 테이블을 엑세스하는 비용이 오라클과 비교할 수 없을 정도로 낮다. 

-> 일반 DBMS에서 인덱스 ROWID를 이용한 테이블 엑세스가 생각만큼 빠르지 않은 이유이다. 

```

## 인덱스 레코드마다 테이블 레코드를 건건이 블록 단위 I/O 한다면, CF가 달라도 블록 I/O 발생량에 차이가 없어야 하지 않나?

```
인덱스 ROWID로 테이블을 엑세스할 때, 오라클은 래치 획득과 해시 체인 스캔 과정을 거쳐 어렵게 찾아간 테이블 블록에 대한 포인터를 바로 해제하지 않고 일단 유지한다.
이를 버퍼 Pinning이라고 부른다
이 상태에서 다음 인덱스 레코드를 읽었는데, 마침 직전과 같은 테이블 블록을 가리킨다. 
그러면 래치 획득과 해시 체인 스캔 과정을 생략하고 바로 테이블 블록을 읽을 수 있다.
논리적인 블록 I/O과정을 생략할 수 있기 때문이다.


```

### 인덱스 손익 분기점이란?
- 인덱스 ROWID를 이요한 테이블 엑세스는 고비용 구조이므로 읽어야할 데이터가 일정량을 넘는 순가, 테이블 전체를 스캔하는 것 보다 오히려 느려진다.
- Index Range Scan에 의한 테이블 엑세스가 Table Full Scan보다 느려지는 지점을 '인덱스 손익 분기점' 이라고 한다. 

![image](https://user-images.githubusercontent.com/55049159/233652564-2709a22c-b063-47fe-b6d6-fa8e8895741c.png)

### 인덱스를 이용한 테이블 엑세스가 Table Full Scan보다 더 느려지게 만드는 핵심적인 요인
1) Table Full Scan은 시퀀셜 엑세스인 반면, 인덱스 ROWID를 이용한 테이블 엑세스는 랜덤 엑세스 방식이다.
2) Table Full Scan은 Mutliblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 엑세스는 Single Block I/O 방식이다.

=> 이런 요인에 의해 인덱스 손익분기점은 보통 5~20%의 낮은 수준에서 결정된다. <br>
=> 테이블 스캔이 항상 나쁜 것이 아니며, 인덱스 스캔이 항상 좋은 것도 아니다.  <br>
=> 배치프로그램과 온라인 프로그램의 튜닝의 특징이 다르다는 걸 시사한다. <br>

```
1) 온라인 프로그램
온라인 프로그램은 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는 것이 중요하다.
NL조인을 대부분 사용한다.
인덱스를 이용해 소트 연산을 생략해서 부분범위 처리 방식으로 구현할 수 있으면 빠른 처리가 가능하다.

2) 배치 프로그램
배치프로그램은 전체범위 처리 기준으로 튜닝해야 한다. 처리대상 집합 중 일부를 빠르게 처리하는 것이 아니라 전체를 빠르게 처리하는 것을 목표로 삼아야 한다.
인덱스와 NL조인 보다는 FULL SCAN과 해시 조인이 유리하다. 

```

### 인덱스 컬럼 추가

- 테이블 엑세스 최소화 하기 위한 방법 중 가장 일반적으로 사용하는 튜닝 기법은 -> 인덱스에 컬럼을 추가하는 것.


#### 예시 

``` sql

-- IDX : EMP_X01 [DEPTNO + JOB]

select /*+ index(emp emp_x01) */
from emp
where deptno = 30
and sal >= 2000

/*
  이와 같은 경우, 위의 조건을 만족하는 사원이 단 한 명 뿐인데도, 이를 찾기 위해 Table Access는 과도하게 발생한다.
  인덱스 구성을 deptno + sal 순으로 바꾸면 좋겠으나 실 운경 환경에서는 인덱스 구성을 변경하기가 어렵다.
  필요한 인덱스를 추가하다보면 인덱스 관리 비용이 증가함은 물론 DML 부하에 따른 트랜잭션 성능 저하가 생길 수 있다.
  이럴 경우 기존 인덱스에 sal 컬럼을 추가하ㅓ 것만으로 큰 효과를 거둘 수 있다
*/
```
![image](https://user-images.githubusercontent.com/55049159/233793143-486ad1a6-0ff8-42c5-8825-8c3bc7ee3d02.png)

```sql

-- IDX : EMP_X01 [DEPTNO + JOB +]

select /*+ index(emp emp_x01) */
from emp
where deptno = 30
and sal >= 2000

/*
  이와 같은 경우, 위의 조건을 만족하는 사원이 단 한 명 뿐인데도, 이를 찾기 위해 Table Access는 과도하게 발생한다.
  인덱스 구성을 deptno + sal 순으로 바꾸면 좋겠으나 실 운경 환경에서는 인덱스 구성을 변경하기가 어렵다.
  필요한 인덱스를 추가하다보면 인덱스 관리 비용이 증가함은 물론 DML 부하에 따른 트랜잭션 성능 저하가 생길 수 있다.
  
  => 이럴 경우 기존 인덱스에 sal 컬럼을 추가하는 것만으로 큰 효과를 거둘 수 있다
*/
```
 
#### PK 인덱스 컬럼 추가

```sql
/*
 단일 테이블을 PK로 액세스할 때는 단 한건만 조회하는 것이므로 테이블 Random 액세스도 단 1회 발생
 NL조인할 때 Inner쪽 (=right side)에서 액세스될 때는 Random 액세스 부하가 만만치 않다
 특히 Outer 테이블에서 Inner 테이블 쪽으로 조인 액세스가 많은 상황에서 Inner쪽 필터 조건에 의해 버려지는 레코드가 많다면 그 비효율은 매우 심각
*/
select /*+ ordered use_nl(d) */*
from   emp e,
       dept d
where  d.deptno = e.deptno
and    d.loc = 'NEW YORK'

Rows     Row Source Operation
-------  ---------------------------------------------------
      3  NESTED LOOPS  (cr=25 pr=0 pw=0 time=198 us)
     14   TABLE ACCESS FULL EMP (cr=8 pr=0 pw=0 time=111 us)
      3   TABLE ACCESS BY INDEX ROWID DEPT (cr=17 pr=0 pw=0 time=223 us)
     14    INDEX UNIQUE SCAN PK_DEPT (cr=3 pr=0 pw=0 time=108 us)(object id 51150)

/*
  Emp를 기준으로 NL조인하고, 조인에 성공한 14건 중 loc='NEW YORK'인 레코드만 취하므로 최종 결과 집합은 3건 뿐이다.
  DEPT_PK인덱스에 loc 컬럼을 추가하면 불필요한 11번의 Random 액세스를 없앨 수 있지만 PK 인덱스에는 컬럼을 추가 할 수 없다.
  PK컬럼 + 필터조건 컬럼 형태의 Non-Unique 인덱스를 추가
  인덱스가 없다면 값이 입력될 때 마다 테이블 전체를 읽어 중복 값 존재 여부를 체크해야 하기 때문에 PK제약에는 중복 값 확인을 위한 인덱스가 반드시 필요하다.
  중복체크를 위해 Non-Unique 인덱스를 이용하여 중복 여부를 체크하며 이때는 one-plus 스캔이 발생하는 약간의 비효율이 있을 수 있다.
*/
```

<hr>
[ref]
http://www.gurubee.net/wiki/pages/28116669




